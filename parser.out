Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    SPACE
    COMMENT
    BREAK
    CONTINUE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM id BEGIN pgm_body END
Rule 2     id -> IDENTIFIER
Rule 3     pgm_body -> decl func_declarations
Rule 4     decl -> string_decl decl
Rule 5     decl -> var_decl decl
Rule 6     decl -> empty
Rule 7     string_decl -> STRING id ASSIGN str SEMICOLON
Rule 8     str -> STRINGLITERAL
Rule 9     var_decl -> var_type id_list SEMICOLON
Rule 10    var_type -> FLOAT
Rule 11    var_type -> INT
Rule 12    any_type -> var_type
Rule 13    any_type -> VOID
Rule 14    id_list -> id id_tail
Rule 15    id_tail -> COMMA id id_tail
Rule 16    id_tail -> empty
Rule 17    param_decl_list -> param_decl param_decl_tail
Rule 18    param_decl_list -> empty
Rule 19    param_decl -> var_type id
Rule 20    param_decl_tail -> COMMA param_decl param_decl_tail
Rule 21    param_decl_tail -> empty
Rule 22    func_declarations -> func_decl func_declarations
Rule 23    func_declarations -> empty
Rule 24    func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END
Rule 25    func_body -> decl stmt_list
Rule 26    stmt_list -> stmt stmt_list
Rule 27    stmt_list -> empty
Rule 28    stmt -> base_stmt
Rule 29    stmt -> if_stmt
Rule 30    stmt -> while_stmt
Rule 31    base_stmt -> assign_stmt
Rule 32    base_stmt -> read_stmt
Rule 33    base_stmt -> write_stmt
Rule 34    base_stmt -> return_stmt
Rule 35    assign_stmt -> assign_expr SEMICOLON
Rule 36    assign_expr -> id ASSIGN expr
Rule 37    read_stmt -> READ LPAREN id_list RPAREN SEMICOLON
Rule 38    write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON
Rule 39    return_stmt -> RETURN expr SEMICOLON
Rule 40    expr -> expr_prefix factor
Rule 41    expr_prefix -> expr_prefix factor addop
Rule 42    expr_prefix -> empty
Rule 43    factor -> factor_prefix postfix_expr
Rule 44    factor_prefix -> factor_prefix postfix_expr mulop
Rule 45    factor_prefix -> empty
Rule 46    postfix_expr -> primary
Rule 47    postfix_expr -> call_expr
Rule 48    call_expr -> id LPAREN expr_list RPAREN
Rule 49    expr_list -> expr expr_list_tail
Rule 50    expr_list -> empty
Rule 51    expr_list_tail -> COMMA expr expr_list_tail
Rule 52    expr_list_tail -> empty
Rule 53    primary -> LPAREN expr RPAREN
Rule 54    primary -> id
Rule 55    primary -> INTLITERAL
Rule 56    primary -> FLOATLITERAL
Rule 57    addop -> PLUS
Rule 58    addop -> MINUS
Rule 59    mulop -> MULTIPLY
Rule 60    mulop -> DIVIDE
Rule 61    if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
Rule 62    else_part -> ELSE decl stmt_list
Rule 63    else_part -> empty
Rule 64    cond -> expr compop expr
Rule 65    compop -> LESS
Rule 66    compop -> GREATER
Rule 67    compop -> EQUAL
Rule 68    compop -> NOTEQUAL
Rule 69    compop -> LESSEQUAL
Rule 70    compop -> GREATEQUAL
Rule 71    while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
Rule 72    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 7 36
BEGIN                : 1 24
BREAK                : 
COMMA                : 15 20 51
COMMENT              : 
CONTINUE             : 
DIVIDE               : 60
ELSE                 : 62
END                  : 1 24
ENDIF                : 61
ENDWHILE             : 71
EQUAL                : 67
FLOAT                : 10
FLOATLITERAL         : 56
FUNCTION             : 24
GREATEQUAL           : 70
GREATER              : 66
IDENTIFIER           : 2
IF                   : 61
INT                  : 11
INTLITERAL           : 55
LESS                 : 65
LESSEQUAL            : 69
LPAREN               : 24 37 38 48 53 61 71
MINUS                : 58
MULTIPLY             : 59
NOTEQUAL             : 68
PLUS                 : 57
PROGRAM              : 1
READ                 : 37
RETURN               : 39
RPAREN               : 24 37 38 48 53 61 71
SEMICOLON            : 7 9 35 37 38 39
SPACE                : 
STRING               : 7
STRINGLITERAL        : 8
VOID                 : 13
WHILE                : 71
WRITE                : 38
error                : 

Nonterminals, with rules where they appear

addop                : 41
any_type             : 24
assign_expr          : 35
assign_stmt          : 31
base_stmt            : 28
call_expr            : 47
compop               : 64
cond                 : 61 71
decl                 : 3 4 5 25 61 62 71
else_part            : 61
empty                : 6 16 18 21 23 27 42 45 50 52 63
expr                 : 36 39 49 51 53 64 64
expr_list            : 48
expr_list_tail       : 49 51
expr_prefix          : 40 41
factor               : 40 41
factor_prefix        : 43 44
func_body            : 24
func_decl            : 22
func_declarations    : 3 22
id                   : 1 7 14 15 19 24 36 48 54
id_list              : 9 37 38
id_tail              : 14 15
if_stmt              : 29
mulop                : 44
param_decl           : 17 20
param_decl_list      : 24
param_decl_tail      : 17 20
pgm_body             : 1
postfix_expr         : 43 44
primary              : 46
program              : 0
read_stmt            : 32
return_stmt          : 34
stmt                 : 26
stmt_list            : 25 26 61 62 71
str                  : 7
string_decl          : 4
var_decl             : 5
var_type             : 9 12 19
while_stmt           : 30
write_stmt           : 33

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM id BEGIN pgm_body END

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . id BEGIN pgm_body END
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 4

state 2

    (0) S' -> program .



state 3

    (2) id -> IDENTIFIER .

    ASSIGN          reduce using rule 2 (id -> IDENTIFIER .)
    BEGIN           reduce using rule 2 (id -> IDENTIFIER .)
    LPAREN          reduce using rule 2 (id -> IDENTIFIER .)
    MULTIPLY        reduce using rule 2 (id -> IDENTIFIER .)
    DIVIDE          reduce using rule 2 (id -> IDENTIFIER .)
    PLUS            reduce using rule 2 (id -> IDENTIFIER .)
    MINUS           reduce using rule 2 (id -> IDENTIFIER .)
    SEMICOLON       reduce using rule 2 (id -> IDENTIFIER .)
    LESS            reduce using rule 2 (id -> IDENTIFIER .)
    GREATER         reduce using rule 2 (id -> IDENTIFIER .)
    EQUAL           reduce using rule 2 (id -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 2 (id -> IDENTIFIER .)
    LESSEQUAL       reduce using rule 2 (id -> IDENTIFIER .)
    GREATEQUAL      reduce using rule 2 (id -> IDENTIFIER .)
    RPAREN          reduce using rule 2 (id -> IDENTIFIER .)
    COMMA           reduce using rule 2 (id -> IDENTIFIER .)


state 4

    (1) program -> PROGRAM id . BEGIN pgm_body END

    BEGIN           shift and go to state 5


state 5

    (1) program -> PROGRAM id BEGIN . pgm_body END
    (3) pgm_body -> . decl func_declarations
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 72 (empty -> .)
    END             reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    pgm_body                       shift and go to state 7
    decl                           shift and go to state 8
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 6

    (6) decl -> empty .

    IF              reduce using rule 6 (decl -> empty .)
    WHILE           reduce using rule 6 (decl -> empty .)
    READ            reduce using rule 6 (decl -> empty .)
    WRITE           reduce using rule 6 (decl -> empty .)
    RETURN          reduce using rule 6 (decl -> empty .)
    IDENTIFIER      reduce using rule 6 (decl -> empty .)
    END             reduce using rule 6 (decl -> empty .)
    ENDIF           reduce using rule 6 (decl -> empty .)
    ELSE            reduce using rule 6 (decl -> empty .)
    FUNCTION        reduce using rule 6 (decl -> empty .)
    ENDWHILE        reduce using rule 6 (decl -> empty .)


state 7

    (1) program -> PROGRAM id BEGIN pgm_body . END

    END             shift and go to state 15


state 8

    (3) pgm_body -> decl . func_declarations
    (22) func_declarations -> . func_decl func_declarations
    (23) func_declarations -> . empty
    (24) func_decl -> . FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END
    (72) empty -> .

    FUNCTION        shift and go to state 18
    END             reduce using rule 72 (empty -> .)

    empty                          shift and go to state 16
    func_decl                      shift and go to state 17
    func_declarations              shift and go to state 19

state 9

    (7) string_decl -> STRING . id ASSIGN str SEMICOLON
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 20

state 10

    (11) var_type -> INT .

    IDENTIFIER      reduce using rule 11 (var_type -> INT .)


state 11

    (10) var_type -> FLOAT .

    IDENTIFIER      reduce using rule 10 (var_type -> FLOAT .)


state 12

    (5) decl -> var_decl . decl
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 72 (empty -> .)
    END             reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    ENDWHILE        reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    decl                           shift and go to state 21
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 13

    (4) decl -> string_decl . decl
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    FUNCTION        reduce using rule 72 (empty -> .)
    END             reduce using rule 72 (empty -> .)
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    ENDWHILE        reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    decl                           shift and go to state 22
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 14

    (9) var_decl -> var_type . id_list SEMICOLON
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 24
    id_list                        shift and go to state 23

state 15

    (1) program -> PROGRAM id BEGIN pgm_body END .

    $end            reduce using rule 1 (program -> PROGRAM id BEGIN pgm_body END .)


state 16

    (23) func_declarations -> empty .

    END             reduce using rule 23 (func_declarations -> empty .)


state 17

    (22) func_declarations -> func_decl . func_declarations
    (22) func_declarations -> . func_decl func_declarations
    (23) func_declarations -> . empty
    (24) func_decl -> . FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END
    (72) empty -> .

    FUNCTION        shift and go to state 18
    END             reduce using rule 72 (empty -> .)

    empty                          shift and go to state 16
    func_decl                      shift and go to state 17
    func_declarations              shift and go to state 25

state 18

    (24) func_decl -> FUNCTION . any_type id LPAREN param_decl_list RPAREN BEGIN func_body END
    (12) any_type -> . var_type
    (13) any_type -> . VOID
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    VOID            shift and go to state 26
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    any_type                       shift and go to state 27
    var_type                       shift and go to state 28

state 19

    (3) pgm_body -> decl func_declarations .

    END             reduce using rule 3 (pgm_body -> decl func_declarations .)


state 20

    (7) string_decl -> STRING id . ASSIGN str SEMICOLON

    ASSIGN          shift and go to state 29


state 21

    (5) decl -> var_decl decl .

    IF              reduce using rule 5 (decl -> var_decl decl .)
    WHILE           reduce using rule 5 (decl -> var_decl decl .)
    READ            reduce using rule 5 (decl -> var_decl decl .)
    WRITE           reduce using rule 5 (decl -> var_decl decl .)
    RETURN          reduce using rule 5 (decl -> var_decl decl .)
    IDENTIFIER      reduce using rule 5 (decl -> var_decl decl .)
    END             reduce using rule 5 (decl -> var_decl decl .)
    ENDIF           reduce using rule 5 (decl -> var_decl decl .)
    ELSE            reduce using rule 5 (decl -> var_decl decl .)
    FUNCTION        reduce using rule 5 (decl -> var_decl decl .)
    ENDWHILE        reduce using rule 5 (decl -> var_decl decl .)


state 22

    (4) decl -> string_decl decl .

    IF              reduce using rule 4 (decl -> string_decl decl .)
    WHILE           reduce using rule 4 (decl -> string_decl decl .)
    READ            reduce using rule 4 (decl -> string_decl decl .)
    WRITE           reduce using rule 4 (decl -> string_decl decl .)
    RETURN          reduce using rule 4 (decl -> string_decl decl .)
    IDENTIFIER      reduce using rule 4 (decl -> string_decl decl .)
    END             reduce using rule 4 (decl -> string_decl decl .)
    ENDIF           reduce using rule 4 (decl -> string_decl decl .)
    ELSE            reduce using rule 4 (decl -> string_decl decl .)
    FUNCTION        reduce using rule 4 (decl -> string_decl decl .)
    ENDWHILE        reduce using rule 4 (decl -> string_decl decl .)


state 23

    (9) var_decl -> var_type id_list . SEMICOLON

    SEMICOLON       shift and go to state 30


state 24

    (14) id_list -> id . id_tail
    (15) id_tail -> . COMMA id id_tail
    (16) id_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 33
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 31
    id_tail                        shift and go to state 32

state 25

    (22) func_declarations -> func_decl func_declarations .

    END             reduce using rule 22 (func_declarations -> func_decl func_declarations .)


state 26

    (13) any_type -> VOID .

    IDENTIFIER      reduce using rule 13 (any_type -> VOID .)


state 27

    (24) func_decl -> FUNCTION any_type . id LPAREN param_decl_list RPAREN BEGIN func_body END
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 34

state 28

    (12) any_type -> var_type .

    IDENTIFIER      reduce using rule 12 (any_type -> var_type .)


state 29

    (7) string_decl -> STRING id ASSIGN . str SEMICOLON
    (8) str -> . STRINGLITERAL

    STRINGLITERAL   shift and go to state 36

    str                            shift and go to state 35

state 30

    (9) var_decl -> var_type id_list SEMICOLON .

    STRING          reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    FLOAT           reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    INT             reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    FUNCTION        reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    END             reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    IF              reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    WHILE           reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    READ            reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    WRITE           reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    RETURN          reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    IDENTIFIER      reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    ELSE            reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    ENDIF           reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)
    ENDWHILE        reduce using rule 9 (var_decl -> var_type id_list SEMICOLON .)


state 31

    (16) id_tail -> empty .

    SEMICOLON       reduce using rule 16 (id_tail -> empty .)
    RPAREN          reduce using rule 16 (id_tail -> empty .)


state 32

    (14) id_list -> id id_tail .

    SEMICOLON       reduce using rule 14 (id_list -> id id_tail .)
    RPAREN          reduce using rule 14 (id_list -> id id_tail .)


state 33

    (15) id_tail -> COMMA . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 37

state 34

    (24) func_decl -> FUNCTION any_type id . LPAREN param_decl_list RPAREN BEGIN func_body END

    LPAREN          shift and go to state 38


state 35

    (7) string_decl -> STRING id ASSIGN str . SEMICOLON

    SEMICOLON       shift and go to state 39


state 36

    (8) str -> STRINGLITERAL .

    SEMICOLON       reduce using rule 8 (str -> STRINGLITERAL .)


state 37

    (15) id_tail -> COMMA id . id_tail
    (15) id_tail -> . COMMA id id_tail
    (16) id_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 33
    SEMICOLON       reduce using rule 72 (empty -> .)
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 31
    id_tail                        shift and go to state 40

state 38

    (24) func_decl -> FUNCTION any_type id LPAREN . param_decl_list RPAREN BEGIN func_body END
    (17) param_decl_list -> . param_decl param_decl_tail
    (18) param_decl_list -> . empty
    (19) param_decl -> . var_type id
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    RPAREN          reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 41
    param_decl                     shift and go to state 44
    param_decl_list                shift and go to state 42
    var_type                       shift and go to state 43

state 39

    (7) string_decl -> STRING id ASSIGN str SEMICOLON .

    STRING          reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    FLOAT           reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    INT             reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    FUNCTION        reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    END             reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    IF              reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    WHILE           reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    READ            reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    WRITE           reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    RETURN          reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    ELSE            reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    ENDIF           reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)
    ENDWHILE        reduce using rule 7 (string_decl -> STRING id ASSIGN str SEMICOLON .)


state 40

    (15) id_tail -> COMMA id id_tail .

    SEMICOLON       reduce using rule 15 (id_tail -> COMMA id id_tail .)
    RPAREN          reduce using rule 15 (id_tail -> COMMA id id_tail .)


state 41

    (18) param_decl_list -> empty .

    RPAREN          reduce using rule 18 (param_decl_list -> empty .)


state 42

    (24) func_decl -> FUNCTION any_type id LPAREN param_decl_list . RPAREN BEGIN func_body END

    RPAREN          shift and go to state 45


state 43

    (19) param_decl -> var_type . id
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 46

state 44

    (17) param_decl_list -> param_decl . param_decl_tail
    (20) param_decl_tail -> . COMMA param_decl param_decl_tail
    (21) param_decl_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 49
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 47
    param_decl_tail                shift and go to state 48

state 45

    (24) func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN . BEGIN func_body END

    BEGIN           shift and go to state 50


state 46

    (19) param_decl -> var_type id .

    COMMA           reduce using rule 19 (param_decl -> var_type id .)
    RPAREN          reduce using rule 19 (param_decl -> var_type id .)


state 47

    (21) param_decl_tail -> empty .

    RPAREN          reduce using rule 21 (param_decl_tail -> empty .)


state 48

    (17) param_decl_list -> param_decl param_decl_tail .

    RPAREN          reduce using rule 17 (param_decl_list -> param_decl param_decl_tail .)


state 49

    (20) param_decl_tail -> COMMA . param_decl param_decl_tail
    (19) param_decl -> . var_type id
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    param_decl                     shift and go to state 51
    var_type                       shift and go to state 43

state 50

    (24) func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN . func_body END
    (25) func_body -> . decl stmt_list
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    END             reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    func_body                      shift and go to state 52
    empty                          shift and go to state 6
    decl                           shift and go to state 53
    var_type                       shift and go to state 14
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12

state 51

    (20) param_decl_tail -> COMMA param_decl . param_decl_tail
    (20) param_decl_tail -> . COMMA param_decl param_decl_tail
    (21) param_decl_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 49
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 47
    param_decl_tail                shift and go to state 54

state 52

    (24) func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body . END

    END             shift and go to state 55


state 53

    (25) func_body -> decl . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (72) empty -> .
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMICOLON
    (37) read_stmt -> . READ LPAREN id_list RPAREN SEMICOLON
    (38) write_stmt -> . WRITE LPAREN id_list RPAREN SEMICOLON
    (39) return_stmt -> . RETURN expr SEMICOLON
    (36) assign_expr -> . id ASSIGN expr
    (2) id -> . IDENTIFIER

    END             reduce using rule 72 (empty -> .)
    IF              shift and go to state 59
    WHILE           shift and go to state 71
    READ            shift and go to state 68
    WRITE           shift and go to state 64
    RETURN          shift and go to state 72
    IDENTIFIER      shift and go to state 3

    empty                          shift and go to state 67
    write_stmt                     shift and go to state 57
    stmt_list                      shift and go to state 58
    assign_stmt                    shift and go to state 60
    stmt                           shift and go to state 69
    read_stmt                      shift and go to state 62
    while_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 61
    assign_expr                    shift and go to state 56
    base_stmt                      shift and go to state 65
    id                             shift and go to state 70
    if_stmt                        shift and go to state 66

state 54

    (20) param_decl_tail -> COMMA param_decl param_decl_tail .

    RPAREN          reduce using rule 20 (param_decl_tail -> COMMA param_decl param_decl_tail .)


state 55

    (24) func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END .

    FUNCTION        reduce using rule 24 (func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END .)
    END             reduce using rule 24 (func_decl -> FUNCTION any_type id LPAREN param_decl_list RPAREN BEGIN func_body END .)


state 56

    (35) assign_stmt -> assign_expr . SEMICOLON

    SEMICOLON       shift and go to state 73


state 57

    (33) base_stmt -> write_stmt .

    IF              reduce using rule 33 (base_stmt -> write_stmt .)
    WHILE           reduce using rule 33 (base_stmt -> write_stmt .)
    READ            reduce using rule 33 (base_stmt -> write_stmt .)
    WRITE           reduce using rule 33 (base_stmt -> write_stmt .)
    RETURN          reduce using rule 33 (base_stmt -> write_stmt .)
    IDENTIFIER      reduce using rule 33 (base_stmt -> write_stmt .)
    ENDWHILE        reduce using rule 33 (base_stmt -> write_stmt .)
    END             reduce using rule 33 (base_stmt -> write_stmt .)
    ENDIF           reduce using rule 33 (base_stmt -> write_stmt .)
    ELSE            reduce using rule 33 (base_stmt -> write_stmt .)


state 58

    (25) func_body -> decl stmt_list .

    END             reduce using rule 25 (func_body -> decl stmt_list .)


state 59

    (61) if_stmt -> IF . LPAREN cond RPAREN decl stmt_list else_part ENDIF

    LPAREN          shift and go to state 74


state 60

    (31) base_stmt -> assign_stmt .

    IF              reduce using rule 31 (base_stmt -> assign_stmt .)
    WHILE           reduce using rule 31 (base_stmt -> assign_stmt .)
    READ            reduce using rule 31 (base_stmt -> assign_stmt .)
    WRITE           reduce using rule 31 (base_stmt -> assign_stmt .)
    RETURN          reduce using rule 31 (base_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 31 (base_stmt -> assign_stmt .)
    ENDWHILE        reduce using rule 31 (base_stmt -> assign_stmt .)
    END             reduce using rule 31 (base_stmt -> assign_stmt .)
    ENDIF           reduce using rule 31 (base_stmt -> assign_stmt .)
    ELSE            reduce using rule 31 (base_stmt -> assign_stmt .)


state 61

    (34) base_stmt -> return_stmt .

    IF              reduce using rule 34 (base_stmt -> return_stmt .)
    WHILE           reduce using rule 34 (base_stmt -> return_stmt .)
    READ            reduce using rule 34 (base_stmt -> return_stmt .)
    WRITE           reduce using rule 34 (base_stmt -> return_stmt .)
    RETURN          reduce using rule 34 (base_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 34 (base_stmt -> return_stmt .)
    ENDWHILE        reduce using rule 34 (base_stmt -> return_stmt .)
    END             reduce using rule 34 (base_stmt -> return_stmt .)
    ENDIF           reduce using rule 34 (base_stmt -> return_stmt .)
    ELSE            reduce using rule 34 (base_stmt -> return_stmt .)


state 62

    (32) base_stmt -> read_stmt .

    IF              reduce using rule 32 (base_stmt -> read_stmt .)
    WHILE           reduce using rule 32 (base_stmt -> read_stmt .)
    READ            reduce using rule 32 (base_stmt -> read_stmt .)
    WRITE           reduce using rule 32 (base_stmt -> read_stmt .)
    RETURN          reduce using rule 32 (base_stmt -> read_stmt .)
    IDENTIFIER      reduce using rule 32 (base_stmt -> read_stmt .)
    ENDWHILE        reduce using rule 32 (base_stmt -> read_stmt .)
    END             reduce using rule 32 (base_stmt -> read_stmt .)
    ENDIF           reduce using rule 32 (base_stmt -> read_stmt .)
    ELSE            reduce using rule 32 (base_stmt -> read_stmt .)


state 63

    (30) stmt -> while_stmt .

    IF              reduce using rule 30 (stmt -> while_stmt .)
    WHILE           reduce using rule 30 (stmt -> while_stmt .)
    READ            reduce using rule 30 (stmt -> while_stmt .)
    WRITE           reduce using rule 30 (stmt -> while_stmt .)
    RETURN          reduce using rule 30 (stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 30 (stmt -> while_stmt .)
    ENDIF           reduce using rule 30 (stmt -> while_stmt .)
    ELSE            reduce using rule 30 (stmt -> while_stmt .)
    END             reduce using rule 30 (stmt -> while_stmt .)
    ENDWHILE        reduce using rule 30 (stmt -> while_stmt .)


state 64

    (38) write_stmt -> WRITE . LPAREN id_list RPAREN SEMICOLON

    LPAREN          shift and go to state 75


state 65

    (28) stmt -> base_stmt .

    IF              reduce using rule 28 (stmt -> base_stmt .)
    WHILE           reduce using rule 28 (stmt -> base_stmt .)
    READ            reduce using rule 28 (stmt -> base_stmt .)
    WRITE           reduce using rule 28 (stmt -> base_stmt .)
    RETURN          reduce using rule 28 (stmt -> base_stmt .)
    IDENTIFIER      reduce using rule 28 (stmt -> base_stmt .)
    ENDIF           reduce using rule 28 (stmt -> base_stmt .)
    ELSE            reduce using rule 28 (stmt -> base_stmt .)
    END             reduce using rule 28 (stmt -> base_stmt .)
    ENDWHILE        reduce using rule 28 (stmt -> base_stmt .)


state 66

    (29) stmt -> if_stmt .

    IF              reduce using rule 29 (stmt -> if_stmt .)
    WHILE           reduce using rule 29 (stmt -> if_stmt .)
    READ            reduce using rule 29 (stmt -> if_stmt .)
    WRITE           reduce using rule 29 (stmt -> if_stmt .)
    RETURN          reduce using rule 29 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 29 (stmt -> if_stmt .)
    ENDIF           reduce using rule 29 (stmt -> if_stmt .)
    ELSE            reduce using rule 29 (stmt -> if_stmt .)
    END             reduce using rule 29 (stmt -> if_stmt .)
    ENDWHILE        reduce using rule 29 (stmt -> if_stmt .)


state 67

    (27) stmt_list -> empty .

    END             reduce using rule 27 (stmt_list -> empty .)
    ENDWHILE        reduce using rule 27 (stmt_list -> empty .)
    ELSE            reduce using rule 27 (stmt_list -> empty .)
    ENDIF           reduce using rule 27 (stmt_list -> empty .)


state 68

    (37) read_stmt -> READ . LPAREN id_list RPAREN SEMICOLON

    LPAREN          shift and go to state 76


state 69

    (26) stmt_list -> stmt . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (72) empty -> .
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMICOLON
    (37) read_stmt -> . READ LPAREN id_list RPAREN SEMICOLON
    (38) write_stmt -> . WRITE LPAREN id_list RPAREN SEMICOLON
    (39) return_stmt -> . RETURN expr SEMICOLON
    (36) assign_expr -> . id ASSIGN expr
    (2) id -> . IDENTIFIER

    END             reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    ENDWHILE        reduce using rule 72 (empty -> .)
    IF              shift and go to state 59
    WHILE           shift and go to state 71
    READ            shift and go to state 68
    WRITE           shift and go to state 64
    RETURN          shift and go to state 72
    IDENTIFIER      shift and go to state 3

    empty                          shift and go to state 67
    write_stmt                     shift and go to state 57
    stmt_list                      shift and go to state 77
    assign_stmt                    shift and go to state 60
    stmt                           shift and go to state 69
    read_stmt                      shift and go to state 62
    while_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 61
    assign_expr                    shift and go to state 56
    base_stmt                      shift and go to state 65
    id                             shift and go to state 70
    if_stmt                        shift and go to state 66

state 70

    (36) assign_expr -> id . ASSIGN expr

    ASSIGN          shift and go to state 78


state 71

    (71) while_stmt -> WHILE . LPAREN cond RPAREN decl stmt_list ENDWHILE

    LPAREN          shift and go to state 79


state 72

    (39) return_stmt -> RETURN . expr SEMICOLON
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    expr                           shift and go to state 82
    expr_prefix                    shift and go to state 81

state 73

    (35) assign_stmt -> assign_expr SEMICOLON .

    IF              reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    WHILE           reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    READ            reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    WRITE           reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    RETURN          reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    IDENTIFIER      reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    ENDIF           reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    END             reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    ELSE            reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)
    ENDWHILE        reduce using rule 35 (assign_stmt -> assign_expr SEMICOLON .)


state 74

    (61) if_stmt -> IF LPAREN . cond RPAREN decl stmt_list else_part ENDIF
    (64) cond -> . expr compop expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    cond                           shift and go to state 84
    expr                           shift and go to state 83
    expr_prefix                    shift and go to state 81

state 75

    (38) write_stmt -> WRITE LPAREN . id_list RPAREN SEMICOLON
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 24
    id_list                        shift and go to state 85

state 76

    (37) read_stmt -> READ LPAREN . id_list RPAREN SEMICOLON
    (14) id_list -> . id id_tail
    (2) id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 3

    id                             shift and go to state 24
    id_list                        shift and go to state 86

state 77

    (26) stmt_list -> stmt stmt_list .

    END             reduce using rule 26 (stmt_list -> stmt stmt_list .)
    ENDWHILE        reduce using rule 26 (stmt_list -> stmt stmt_list .)
    ELSE            reduce using rule 26 (stmt_list -> stmt stmt_list .)
    ENDIF           reduce using rule 26 (stmt_list -> stmt stmt_list .)


state 78

    (36) assign_expr -> id ASSIGN . expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    expr_prefix                    shift and go to state 81
    expr                           shift and go to state 87

state 79

    (71) while_stmt -> WHILE LPAREN . cond RPAREN decl stmt_list ENDWHILE
    (64) cond -> . expr compop expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    cond                           shift and go to state 88
    expr                           shift and go to state 83
    expr_prefix                    shift and go to state 81

state 80

    (42) expr_prefix -> empty .

    LPAREN          reduce using rule 42 (expr_prefix -> empty .)
    INTLITERAL      reduce using rule 42 (expr_prefix -> empty .)
    FLOATLITERAL    reduce using rule 42 (expr_prefix -> empty .)
    IDENTIFIER      reduce using rule 42 (expr_prefix -> empty .)


state 81

    (40) expr -> expr_prefix . factor
    (41) expr_prefix -> expr_prefix . factor addop
    (43) factor -> . factor_prefix postfix_expr
    (44) factor_prefix -> . factor_prefix postfix_expr mulop
    (45) factor_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 89
    factor_prefix                  shift and go to state 90
    factor                         shift and go to state 91

state 82

    (39) return_stmt -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 92


state 83

    (64) cond -> expr . compop expr
    (65) compop -> . LESS
    (66) compop -> . GREATER
    (67) compop -> . EQUAL
    (68) compop -> . NOTEQUAL
    (69) compop -> . LESSEQUAL
    (70) compop -> . GREATEQUAL

    LESS            shift and go to state 99
    GREATER         shift and go to state 95
    EQUAL           shift and go to state 94
    NOTEQUAL        shift and go to state 93
    LESSEQUAL       shift and go to state 96
    GREATEQUAL      shift and go to state 97

    compop                         shift and go to state 98

state 84

    (61) if_stmt -> IF LPAREN cond . RPAREN decl stmt_list else_part ENDIF

    RPAREN          shift and go to state 100


state 85

    (38) write_stmt -> WRITE LPAREN id_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 101


state 86

    (37) read_stmt -> READ LPAREN id_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 102


state 87

    (36) assign_expr -> id ASSIGN expr .

    SEMICOLON       reduce using rule 36 (assign_expr -> id ASSIGN expr .)


state 88

    (71) while_stmt -> WHILE LPAREN cond . RPAREN decl stmt_list ENDWHILE

    RPAREN          shift and go to state 103


state 89

    (45) factor_prefix -> empty .

    LPAREN          reduce using rule 45 (factor_prefix -> empty .)
    INTLITERAL      reduce using rule 45 (factor_prefix -> empty .)
    FLOATLITERAL    reduce using rule 45 (factor_prefix -> empty .)
    IDENTIFIER      reduce using rule 45 (factor_prefix -> empty .)


state 90

    (43) factor -> factor_prefix . postfix_expr
    (44) factor_prefix -> factor_prefix . postfix_expr mulop
    (46) postfix_expr -> . primary
    (47) postfix_expr -> . call_expr
    (53) primary -> . LPAREN expr RPAREN
    (54) primary -> . id
    (55) primary -> . INTLITERAL
    (56) primary -> . FLOATLITERAL
    (48) call_expr -> . id LPAREN expr_list RPAREN
    (2) id -> . IDENTIFIER

    LPAREN          shift and go to state 110
    INTLITERAL      shift and go to state 107
    FLOATLITERAL    shift and go to state 104
    IDENTIFIER      shift and go to state 3

    primary                        shift and go to state 108
    postfix_expr                   shift and go to state 109
    id                             shift and go to state 105
    call_expr                      shift and go to state 106

state 91

    (40) expr -> expr_prefix factor .
    (41) expr_prefix -> expr_prefix factor . addop
    (57) addop -> . PLUS
    (58) addop -> . MINUS

    RPAREN          reduce using rule 40 (expr -> expr_prefix factor .)
    SEMICOLON       reduce using rule 40 (expr -> expr_prefix factor .)
    COMMA           reduce using rule 40 (expr -> expr_prefix factor .)
    LESS            reduce using rule 40 (expr -> expr_prefix factor .)
    GREATER         reduce using rule 40 (expr -> expr_prefix factor .)
    EQUAL           reduce using rule 40 (expr -> expr_prefix factor .)
    NOTEQUAL        reduce using rule 40 (expr -> expr_prefix factor .)
    LESSEQUAL       reduce using rule 40 (expr -> expr_prefix factor .)
    GREATEQUAL      reduce using rule 40 (expr -> expr_prefix factor .)
    PLUS            shift and go to state 113
    MINUS           shift and go to state 112

    addop                          shift and go to state 111

state 92

    (39) return_stmt -> RETURN expr SEMICOLON .

    IF              reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    READ            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    WRITE           reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    ENDWHILE        reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    ENDIF           reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    END             reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)


state 93

    (68) compop -> NOTEQUAL .

    LPAREN          reduce using rule 68 (compop -> NOTEQUAL .)
    INTLITERAL      reduce using rule 68 (compop -> NOTEQUAL .)
    FLOATLITERAL    reduce using rule 68 (compop -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 68 (compop -> NOTEQUAL .)


state 94

    (67) compop -> EQUAL .

    LPAREN          reduce using rule 67 (compop -> EQUAL .)
    INTLITERAL      reduce using rule 67 (compop -> EQUAL .)
    FLOATLITERAL    reduce using rule 67 (compop -> EQUAL .)
    IDENTIFIER      reduce using rule 67 (compop -> EQUAL .)


state 95

    (66) compop -> GREATER .

    LPAREN          reduce using rule 66 (compop -> GREATER .)
    INTLITERAL      reduce using rule 66 (compop -> GREATER .)
    FLOATLITERAL    reduce using rule 66 (compop -> GREATER .)
    IDENTIFIER      reduce using rule 66 (compop -> GREATER .)


state 96

    (69) compop -> LESSEQUAL .

    LPAREN          reduce using rule 69 (compop -> LESSEQUAL .)
    INTLITERAL      reduce using rule 69 (compop -> LESSEQUAL .)
    FLOATLITERAL    reduce using rule 69 (compop -> LESSEQUAL .)
    IDENTIFIER      reduce using rule 69 (compop -> LESSEQUAL .)


state 97

    (70) compop -> GREATEQUAL .

    LPAREN          reduce using rule 70 (compop -> GREATEQUAL .)
    INTLITERAL      reduce using rule 70 (compop -> GREATEQUAL .)
    FLOATLITERAL    reduce using rule 70 (compop -> GREATEQUAL .)
    IDENTIFIER      reduce using rule 70 (compop -> GREATEQUAL .)


state 98

    (64) cond -> expr compop . expr
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    expr_prefix                    shift and go to state 81
    expr                           shift and go to state 114

state 99

    (65) compop -> LESS .

    LPAREN          reduce using rule 65 (compop -> LESS .)
    INTLITERAL      reduce using rule 65 (compop -> LESS .)
    FLOATLITERAL    reduce using rule 65 (compop -> LESS .)
    IDENTIFIER      reduce using rule 65 (compop -> LESS .)


state 100

    (61) if_stmt -> IF LPAREN cond RPAREN . decl stmt_list else_part ENDIF
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    ELSE            reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    decl                           shift and go to state 115
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 101

    (38) write_stmt -> WRITE LPAREN id_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 116


state 102

    (37) read_stmt -> READ LPAREN id_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 117


state 103

    (71) while_stmt -> WHILE LPAREN cond RPAREN . decl stmt_list ENDWHILE
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    ENDWHILE        reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    decl                           shift and go to state 118
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 104

    (56) primary -> FLOATLITERAL .

    MULTIPLY        reduce using rule 56 (primary -> FLOATLITERAL .)
    DIVIDE          reduce using rule 56 (primary -> FLOATLITERAL .)
    PLUS            reduce using rule 56 (primary -> FLOATLITERAL .)
    MINUS           reduce using rule 56 (primary -> FLOATLITERAL .)
    SEMICOLON       reduce using rule 56 (primary -> FLOATLITERAL .)
    LESS            reduce using rule 56 (primary -> FLOATLITERAL .)
    GREATER         reduce using rule 56 (primary -> FLOATLITERAL .)
    EQUAL           reduce using rule 56 (primary -> FLOATLITERAL .)
    NOTEQUAL        reduce using rule 56 (primary -> FLOATLITERAL .)
    LESSEQUAL       reduce using rule 56 (primary -> FLOATLITERAL .)
    GREATEQUAL      reduce using rule 56 (primary -> FLOATLITERAL .)
    RPAREN          reduce using rule 56 (primary -> FLOATLITERAL .)
    COMMA           reduce using rule 56 (primary -> FLOATLITERAL .)


state 105

    (54) primary -> id .
    (48) call_expr -> id . LPAREN expr_list RPAREN

    MULTIPLY        reduce using rule 54 (primary -> id .)
    DIVIDE          reduce using rule 54 (primary -> id .)
    PLUS            reduce using rule 54 (primary -> id .)
    MINUS           reduce using rule 54 (primary -> id .)
    SEMICOLON       reduce using rule 54 (primary -> id .)
    LESS            reduce using rule 54 (primary -> id .)
    GREATER         reduce using rule 54 (primary -> id .)
    EQUAL           reduce using rule 54 (primary -> id .)
    NOTEQUAL        reduce using rule 54 (primary -> id .)
    LESSEQUAL       reduce using rule 54 (primary -> id .)
    GREATEQUAL      reduce using rule 54 (primary -> id .)
    RPAREN          reduce using rule 54 (primary -> id .)
    COMMA           reduce using rule 54 (primary -> id .)
    LPAREN          shift and go to state 119


state 106

    (47) postfix_expr -> call_expr .

    MULTIPLY        reduce using rule 47 (postfix_expr -> call_expr .)
    DIVIDE          reduce using rule 47 (postfix_expr -> call_expr .)
    PLUS            reduce using rule 47 (postfix_expr -> call_expr .)
    MINUS           reduce using rule 47 (postfix_expr -> call_expr .)
    SEMICOLON       reduce using rule 47 (postfix_expr -> call_expr .)
    LESS            reduce using rule 47 (postfix_expr -> call_expr .)
    GREATER         reduce using rule 47 (postfix_expr -> call_expr .)
    EQUAL           reduce using rule 47 (postfix_expr -> call_expr .)
    NOTEQUAL        reduce using rule 47 (postfix_expr -> call_expr .)
    LESSEQUAL       reduce using rule 47 (postfix_expr -> call_expr .)
    GREATEQUAL      reduce using rule 47 (postfix_expr -> call_expr .)
    RPAREN          reduce using rule 47 (postfix_expr -> call_expr .)
    COMMA           reduce using rule 47 (postfix_expr -> call_expr .)


state 107

    (55) primary -> INTLITERAL .

    MULTIPLY        reduce using rule 55 (primary -> INTLITERAL .)
    DIVIDE          reduce using rule 55 (primary -> INTLITERAL .)
    PLUS            reduce using rule 55 (primary -> INTLITERAL .)
    MINUS           reduce using rule 55 (primary -> INTLITERAL .)
    SEMICOLON       reduce using rule 55 (primary -> INTLITERAL .)
    LESS            reduce using rule 55 (primary -> INTLITERAL .)
    GREATER         reduce using rule 55 (primary -> INTLITERAL .)
    EQUAL           reduce using rule 55 (primary -> INTLITERAL .)
    NOTEQUAL        reduce using rule 55 (primary -> INTLITERAL .)
    LESSEQUAL       reduce using rule 55 (primary -> INTLITERAL .)
    GREATEQUAL      reduce using rule 55 (primary -> INTLITERAL .)
    RPAREN          reduce using rule 55 (primary -> INTLITERAL .)
    COMMA           reduce using rule 55 (primary -> INTLITERAL .)


state 108

    (46) postfix_expr -> primary .

    MULTIPLY        reduce using rule 46 (postfix_expr -> primary .)
    DIVIDE          reduce using rule 46 (postfix_expr -> primary .)
    PLUS            reduce using rule 46 (postfix_expr -> primary .)
    MINUS           reduce using rule 46 (postfix_expr -> primary .)
    SEMICOLON       reduce using rule 46 (postfix_expr -> primary .)
    LESS            reduce using rule 46 (postfix_expr -> primary .)
    GREATER         reduce using rule 46 (postfix_expr -> primary .)
    EQUAL           reduce using rule 46 (postfix_expr -> primary .)
    NOTEQUAL        reduce using rule 46 (postfix_expr -> primary .)
    LESSEQUAL       reduce using rule 46 (postfix_expr -> primary .)
    GREATEQUAL      reduce using rule 46 (postfix_expr -> primary .)
    RPAREN          reduce using rule 46 (postfix_expr -> primary .)
    COMMA           reduce using rule 46 (postfix_expr -> primary .)


state 109

    (43) factor -> factor_prefix postfix_expr .
    (44) factor_prefix -> factor_prefix postfix_expr . mulop
    (59) mulop -> . MULTIPLY
    (60) mulop -> . DIVIDE

    PLUS            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    MINUS           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    SEMICOLON       reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    LESS            reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    GREATER         reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    EQUAL           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    NOTEQUAL        reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    LESSEQUAL       reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    GREATEQUAL      reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    RPAREN          reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    COMMA           reduce using rule 43 (factor -> factor_prefix postfix_expr .)
    MULTIPLY        shift and go to state 121
    DIVIDE          shift and go to state 120

    mulop                          shift and go to state 122

state 110

    (53) primary -> LPAREN . expr RPAREN
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    expr                           shift and go to state 123
    expr_prefix                    shift and go to state 81

state 111

    (41) expr_prefix -> expr_prefix factor addop .

    LPAREN          reduce using rule 41 (expr_prefix -> expr_prefix factor addop .)
    INTLITERAL      reduce using rule 41 (expr_prefix -> expr_prefix factor addop .)
    FLOATLITERAL    reduce using rule 41 (expr_prefix -> expr_prefix factor addop .)
    IDENTIFIER      reduce using rule 41 (expr_prefix -> expr_prefix factor addop .)


state 112

    (58) addop -> MINUS .

    LPAREN          reduce using rule 58 (addop -> MINUS .)
    INTLITERAL      reduce using rule 58 (addop -> MINUS .)
    FLOATLITERAL    reduce using rule 58 (addop -> MINUS .)
    IDENTIFIER      reduce using rule 58 (addop -> MINUS .)


state 113

    (57) addop -> PLUS .

    LPAREN          reduce using rule 57 (addop -> PLUS .)
    INTLITERAL      reduce using rule 57 (addop -> PLUS .)
    FLOATLITERAL    reduce using rule 57 (addop -> PLUS .)
    IDENTIFIER      reduce using rule 57 (addop -> PLUS .)


state 114

    (64) cond -> expr compop expr .

    RPAREN          reduce using rule 64 (cond -> expr compop expr .)


state 115

    (61) if_stmt -> IF LPAREN cond RPAREN decl . stmt_list else_part ENDIF
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (72) empty -> .
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMICOLON
    (37) read_stmt -> . READ LPAREN id_list RPAREN SEMICOLON
    (38) write_stmt -> . WRITE LPAREN id_list RPAREN SEMICOLON
    (39) return_stmt -> . RETURN expr SEMICOLON
    (36) assign_expr -> . id ASSIGN expr
    (2) id -> . IDENTIFIER

    ELSE            reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    IF              shift and go to state 59
    WHILE           shift and go to state 71
    READ            shift and go to state 68
    WRITE           shift and go to state 64
    RETURN          shift and go to state 72
    IDENTIFIER      shift and go to state 3

    empty                          shift and go to state 67
    write_stmt                     shift and go to state 57
    stmt_list                      shift and go to state 124
    assign_stmt                    shift and go to state 60
    stmt                           shift and go to state 69
    read_stmt                      shift and go to state 62
    while_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 61
    assign_expr                    shift and go to state 56
    base_stmt                      shift and go to state 65
    id                             shift and go to state 70
    if_stmt                        shift and go to state 66

state 116

    (38) write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .

    IF              reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    READ            reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    WRITE           reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    ENDIF           reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    ELSE            reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    END             reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)
    ENDWHILE        reduce using rule 38 (write_stmt -> WRITE LPAREN id_list RPAREN SEMICOLON .)


state 117

    (37) read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .

    IF              reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    READ            reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    WRITE           reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    ENDIF           reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    END             reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    ENDWHILE        reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)
    ELSE            reduce using rule 37 (read_stmt -> READ LPAREN id_list RPAREN SEMICOLON .)


state 118

    (71) while_stmt -> WHILE LPAREN cond RPAREN decl . stmt_list ENDWHILE
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (72) empty -> .
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMICOLON
    (37) read_stmt -> . READ LPAREN id_list RPAREN SEMICOLON
    (38) write_stmt -> . WRITE LPAREN id_list RPAREN SEMICOLON
    (39) return_stmt -> . RETURN expr SEMICOLON
    (36) assign_expr -> . id ASSIGN expr
    (2) id -> . IDENTIFIER

    ENDWHILE        reduce using rule 72 (empty -> .)
    IF              shift and go to state 59
    WHILE           shift and go to state 71
    READ            shift and go to state 68
    WRITE           shift and go to state 64
    RETURN          shift and go to state 72
    IDENTIFIER      shift and go to state 3

    empty                          shift and go to state 67
    write_stmt                     shift and go to state 57
    stmt_list                      shift and go to state 125
    assign_stmt                    shift and go to state 60
    stmt                           shift and go to state 69
    read_stmt                      shift and go to state 62
    while_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 61
    assign_expr                    shift and go to state 56
    base_stmt                      shift and go to state 65
    id                             shift and go to state 70
    if_stmt                        shift and go to state 66

state 119

    (48) call_expr -> id LPAREN . expr_list RPAREN
    (49) expr_list -> . expr expr_list_tail
    (50) expr_list -> . empty
    (40) expr -> . expr_prefix factor
    (72) empty -> .
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty

    RPAREN          reduce using rule 72 (empty -> .)
    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 126
    expr_prefix                    shift and go to state 81
    expr                           shift and go to state 127
    expr_list                      shift and go to state 128

state 120

    (60) mulop -> DIVIDE .

    LPAREN          reduce using rule 60 (mulop -> DIVIDE .)
    INTLITERAL      reduce using rule 60 (mulop -> DIVIDE .)
    FLOATLITERAL    reduce using rule 60 (mulop -> DIVIDE .)
    IDENTIFIER      reduce using rule 60 (mulop -> DIVIDE .)


state 121

    (59) mulop -> MULTIPLY .

    LPAREN          reduce using rule 59 (mulop -> MULTIPLY .)
    INTLITERAL      reduce using rule 59 (mulop -> MULTIPLY .)
    FLOATLITERAL    reduce using rule 59 (mulop -> MULTIPLY .)
    IDENTIFIER      reduce using rule 59 (mulop -> MULTIPLY .)


state 122

    (44) factor_prefix -> factor_prefix postfix_expr mulop .

    LPAREN          reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    INTLITERAL      reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    FLOATLITERAL    reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)
    IDENTIFIER      reduce using rule 44 (factor_prefix -> factor_prefix postfix_expr mulop .)


state 123

    (53) primary -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 129


state 124

    (61) if_stmt -> IF LPAREN cond RPAREN decl stmt_list . else_part ENDIF
    (62) else_part -> . ELSE decl stmt_list
    (63) else_part -> . empty
    (72) empty -> .

    ELSE            shift and go to state 131
    ENDIF           reduce using rule 72 (empty -> .)

    empty                          shift and go to state 130
    else_part                      shift and go to state 132

state 125

    (71) while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list . ENDWHILE

    ENDWHILE        shift and go to state 133


state 126

    (50) expr_list -> empty .
    (42) expr_prefix -> empty .

    RPAREN          reduce using rule 50 (expr_list -> empty .)
    LPAREN          reduce using rule 42 (expr_prefix -> empty .)
    INTLITERAL      reduce using rule 42 (expr_prefix -> empty .)
    FLOATLITERAL    reduce using rule 42 (expr_prefix -> empty .)
    IDENTIFIER      reduce using rule 42 (expr_prefix -> empty .)


state 127

    (49) expr_list -> expr . expr_list_tail
    (51) expr_list_tail -> . COMMA expr expr_list_tail
    (52) expr_list_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 135
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 134
    expr_list_tail                 shift and go to state 136

state 128

    (48) call_expr -> id LPAREN expr_list . RPAREN

    RPAREN          shift and go to state 137


state 129

    (53) primary -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    LESS            reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    NOTEQUAL        reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    LESSEQUAL       reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    GREATEQUAL      reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 53 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 53 (primary -> LPAREN expr RPAREN .)


state 130

    (63) else_part -> empty .

    ENDIF           reduce using rule 63 (else_part -> empty .)


state 131

    (62) else_part -> ELSE . decl stmt_list
    (4) decl -> . string_decl decl
    (5) decl -> . var_decl decl
    (6) decl -> . empty
    (7) string_decl -> . STRING id ASSIGN str SEMICOLON
    (9) var_decl -> . var_type id_list SEMICOLON
    (72) empty -> .
    (10) var_type -> . FLOAT
    (11) var_type -> . INT

    STRING          shift and go to state 9
    IF              reduce using rule 72 (empty -> .)
    WHILE           reduce using rule 72 (empty -> .)
    READ            reduce using rule 72 (empty -> .)
    WRITE           reduce using rule 72 (empty -> .)
    RETURN          reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)
    ENDIF           reduce using rule 72 (empty -> .)
    FLOAT           shift and go to state 11
    INT             shift and go to state 10

    empty                          shift and go to state 6
    decl                           shift and go to state 138
    string_decl                    shift and go to state 13
    var_decl                       shift and go to state 12
    var_type                       shift and go to state 14

state 132

    (61) if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part . ENDIF

    ENDIF           shift and go to state 139


state 133

    (71) while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .

    IF              reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    WHILE           reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    READ            reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    WRITE           reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    RETURN          reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    IDENTIFIER      reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    END             reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    ELSE            reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    ENDIF           reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)
    ENDWHILE        reduce using rule 71 (while_stmt -> WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE .)


state 134

    (52) expr_list_tail -> empty .

    RPAREN          reduce using rule 52 (expr_list_tail -> empty .)


state 135

    (51) expr_list_tail -> COMMA . expr expr_list_tail
    (40) expr -> . expr_prefix factor
    (41) expr_prefix -> . expr_prefix factor addop
    (42) expr_prefix -> . empty
    (72) empty -> .

    LPAREN          reduce using rule 72 (empty -> .)
    INTLITERAL      reduce using rule 72 (empty -> .)
    FLOATLITERAL    reduce using rule 72 (empty -> .)
    IDENTIFIER      reduce using rule 72 (empty -> .)

    empty                          shift and go to state 80
    expr_prefix                    shift and go to state 81
    expr                           shift and go to state 140

state 136

    (49) expr_list -> expr expr_list_tail .

    RPAREN          reduce using rule 49 (expr_list -> expr expr_list_tail .)


state 137

    (48) call_expr -> id LPAREN expr_list RPAREN .

    MULTIPLY        reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    DIVIDE          reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    PLUS            reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    SEMICOLON       reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    LESS            reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    GREATER         reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    EQUAL           reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    NOTEQUAL        reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    LESSEQUAL       reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    GREATEQUAL      reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 48 (call_expr -> id LPAREN expr_list RPAREN .)


state 138

    (62) else_part -> ELSE decl . stmt_list
    (26) stmt_list -> . stmt stmt_list
    (27) stmt_list -> . empty
    (28) stmt -> . base_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . while_stmt
    (72) empty -> .
    (31) base_stmt -> . assign_stmt
    (32) base_stmt -> . read_stmt
    (33) base_stmt -> . write_stmt
    (34) base_stmt -> . return_stmt
    (61) if_stmt -> . IF LPAREN cond RPAREN decl stmt_list else_part ENDIF
    (71) while_stmt -> . WHILE LPAREN cond RPAREN decl stmt_list ENDWHILE
    (35) assign_stmt -> . assign_expr SEMICOLON
    (37) read_stmt -> . READ LPAREN id_list RPAREN SEMICOLON
    (38) write_stmt -> . WRITE LPAREN id_list RPAREN SEMICOLON
    (39) return_stmt -> . RETURN expr SEMICOLON
    (36) assign_expr -> . id ASSIGN expr
    (2) id -> . IDENTIFIER

    ENDIF           reduce using rule 72 (empty -> .)
    IF              shift and go to state 59
    WHILE           shift and go to state 71
    READ            shift and go to state 68
    WRITE           shift and go to state 64
    RETURN          shift and go to state 72
    IDENTIFIER      shift and go to state 3

    empty                          shift and go to state 67
    write_stmt                     shift and go to state 57
    stmt_list                      shift and go to state 141
    assign_stmt                    shift and go to state 60
    stmt                           shift and go to state 69
    read_stmt                      shift and go to state 62
    while_stmt                     shift and go to state 63
    return_stmt                    shift and go to state 61
    assign_expr                    shift and go to state 56
    base_stmt                      shift and go to state 65
    id                             shift and go to state 70
    if_stmt                        shift and go to state 66

state 139

    (61) if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .

    IF              reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    WHILE           reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    READ            reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    WRITE           reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    RETURN          reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    IDENTIFIER      reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    END             reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    ELSE            reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    ENDIF           reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)
    ENDWHILE        reduce using rule 61 (if_stmt -> IF LPAREN cond RPAREN decl stmt_list else_part ENDIF .)


state 140

    (51) expr_list_tail -> COMMA expr . expr_list_tail
    (51) expr_list_tail -> . COMMA expr expr_list_tail
    (52) expr_list_tail -> . empty
    (72) empty -> .

    COMMA           shift and go to state 135
    RPAREN          reduce using rule 72 (empty -> .)

    empty                          shift and go to state 134
    expr_list_tail                 shift and go to state 142

state 141

    (62) else_part -> ELSE decl stmt_list .

    ENDIF           reduce using rule 62 (else_part -> ELSE decl stmt_list .)


state 142

    (51) expr_list_tail -> COMMA expr expr_list_tail .

    RPAREN          reduce using rule 51 (expr_list_tail -> COMMA expr expr_list_tail .)

